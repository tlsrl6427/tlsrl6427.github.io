---
title: "언어의 이식성과 편리성 발전"
categories: [cs]
tags: [cs, computer science]
published: false
---

### 서론
&nbsp;[스프링 입문을 위한 자바 객체 지향의 원리와 이해](https://product.kyobobook.co.kr/detail/S000001628116) 책 맨처음인 "기계어에서 객체 지향 프로그래밍 언어로"라는 챕터이다.<br>
<br>
&nbsp;어떤 것의 장점을 찾기 위한 제일 쉬운 방법은 다른 것과의 비교라고 생각한다. 이 챕터에서는 최초의 기계어부터 자바에 이르기까지의 발전 과정을 담았는데 발전 단계의 각각을 비교하며 어떤 이점이 있는지 비교하며 설명해서 보기 좋았다.<br>
<br>
&nbsp;아직 책을 다 읽지는 않았지만 객체지향 관련 부분까지 읽었는데 아직까지는 이 맨처음 챕터가 제일 재밌었다. 중요한 부분은 아니지만 이 과정을 잘 이해할 수 있으면 언어나 프레임워크같은 것들의 발전 과정을 이해할 때 더 편하다고 생각해 정리하게 되었다.   
<br>
### 기계어
0과 1로 이루어진 언어이다. 이건 너무 어렵다. 예제를 보면<br>
<br>
```
[EDSAC]의 기계어
001010101 00000001 0001001
   1         +       3
```
<br>
&nbsp;단순한 더하기 연산도 이런데 어떤 기능을 하게하려면 -의 기계어는 뭔지, /의 기계어는 뭔지 등의 경우를 모두 0과 1의 조합으로 외워야 되니 상상이 안간다.   
대치되는 조합을 외우기 어려운데 더불어, 컴퓨터마다 그 조합이 다른 것도 큰 문제였다.<br>
<br>
<br>

- 지금으로 치자면<br>
<br>
&nbsp;윈도우, 맥, 리눅스용 각각의 기계어 조합이 필요하다. 만약에 어떤 회사가 어떤 프로그램을 만든다고 하면 컴퓨터마다 각각의 개발자들을 지니고 있어야할 것이다.<br>
<br>
EX. 더하기 연산<br>
<br>
윈도우 + : 00001111<br>
&emsp;맥 &emsp;+ : 01010101<br>
리눅스 + : 11110000<br>
<br>
총 N개의 파일<br>
<br>

### 어셈블리어
&nbsp;어셈블리어는 기계어보다는 한창 보기 쉽게 기계어를 사람 언어로 매치시킨 것이다.<br>
<br>
```
[EDSAC]의 어셈블리어
+ = 00000001(기계어) = add(어셈블리어)
```
<br>
&nbsp; 확실히 사람이 보기에 편한 언어가 되었다. 그럼 이걸로 코딩하면 안되나요?<br>
<br>
음.. 아마 난 조금 힘들 것 같긴하다. [블로그](https://coding-factory.tistory.com/651) 를 참고해보니 어셈블리어로 자주 쓰는 명령어는 우리가 평소에 쓰는 명령어와는 다르게 더 딥하게 메모리와 레지스터에 접근하는 명령어이다.
여기에 나와있는 C언어 예제를 보면<br>
<br>

```cpp
#include<stdio.h>

int main() {
    int a = 1;
    int b = 2;	
    int c = a + b;
    
    printf("%d", c);
}
```
<center>↓</center>

```
 push        ebp  
 mov         ebp,esp  
 sub         esp,0E4h  
 push        ebx  
 push        esi  
 push        edi  
 lea         edi,[ebp+FFFFFF1Ch]  
 mov         ecx,39h  
 mov         eax,0CCCCCCCCh  
 rep stos    dword ptr es:[edi]  
 mov         ecx,9AC003h  
 call        009A1316  
 mov         dword ptr [ebp-8],1  
 mov         dword ptr [ebp-14h],2  
 mov         eax,dword ptr [ebp-8]  
 add         eax,dword ptr [ebp-14h]  
 mov         dword ptr [ebp-20h],eax  
 mov         eax,dword ptr [ebp-20h]  
 push        eax  
 push        9A7D08h  
 call        009A10CD  
 add         esp,8  
 xor         eax,eax  
 pop         edi  
 pop         esi  
 pop         ebx  
 add         esp,0E4h  
 cmp         ebp,esp  
 call        009A123F  
 mov         esp,ebp  
 pop         ebp  
 ret  
```
<br>
&nbsp; 음... 어지럽다. 보면 메모리에 있는 것을 포인터를 통해 레지스터로 옮기고 add로 더한 후 어쩌구해서 된 것을 볼 수 있다. 어셈블리어도 기계어보다는 확실히 가시성이 좋아졌지만 지금 우리의 시각에선 조금 힘들어보인다. 다만 뭔가 반도체같은 것을 만져야될 때는 꼭 알아야할 것 같은 느낌이다.<br>
<br>
&nbsp; 하지만 어셈블리어도 기계어때와 마찬가지로 컴퓨터에 따라 약간씩 명령어가 다른 것은 숙제였다.<br>
<br>
<br>

- 지금으로 치자면<br>
<br>
&nbsp;윈도우, 맥, 리눅스용 각각의 <ins>어셈블리어</ins> 조합이 필요하다. 만약에 어떤 회사가 어떤 프로그램을 만든다고 하면 컴퓨터마다 각각의 개발자들을 지니고 있어야할 것이다.<br>
<br>
EX. 더하기 연산<br>
<br>
윈도우 + : add<br>
&emsp;맥 &emsp;+ : plus<br>
리눅스 + : sum<br>
<br>
총 N개의 파일<br>
<br>

### C 언어
&nbsp; 어셈블리어의 가장 큰 이점은 기계어가 사람이 치기에 편한 명령어로 바뀌었다는 것이다. 그렇다면 C에서의 이점은 무엇일까?<br>
<br>
&nbsp; 일단은 위의 예제에 나온대로 명령어가 어셈블리어보다 더욱 간결하게 되었다. 이것도 있지만 여기서는 이식성을 주목하고 싶다. 위의 기계어와 어셈블리어 모두 각각의 컴퓨터에 맞는 코드를 새로 적어야했다. C언어는 그럴 필요없이 코드는 한번만 적으면 된다. 어떻게? **컴파일러**를 이용해서이다.
<br>
<br>
![img1](/assets/img/2024-07-26-history/img1.jpg)
<br>
<br>
&nbsp; 책에 나온 그림이다. 보면 한번만 코딩을 하면 각각 컴퓨터에 맞는 컴파일러를 돌려 목적 파일을 만들어 실행시키는 것을 볼 수 있다. 3개의 운영체제라 생각해도 3배의 힘을 아낄 수 있으니 좋은 발전이다.
<br>
<br>

- 지금으로 치자면<br>
<br>
&nbsp;윈도우, 맥, 리눅스용 각각의 <ins>컴파일러</ins>가 필요하다. 만약에 어떤 회사가 어떤 프로그램을 만든다고 하면 각각의 운영체제에 맞는 컴파일러로 여러번 컴파일을 돌리면 된다.<br>
<br>
EX. <br>
<br>
기계어, 어셈블리어 : 윈도우, 맥, 리눅스에 맞게 같은 내용의 코딩을 3번해야한다<br>
C 언어: 한번 코딩을 하고 윈도우, 맥, 리눅스에 맞는 각각의 컴파일러로 총 3번 컴파일한다<br>
<br>
총 1개의 파일, N번의 컴파일<br>
<br>


### JAVA
&nbsp; C 언어의 이식성도 획기적인데 여기서 더 나아갈 수 있을까? 자바도 객체지향 등 많은 것이 바뀌었지만 일관적이게 이식성의 발전을 살펴보겠다.<br>
<br>
![img2](/assets/img/2024-07-26-history/img2.jpg)
<br>
<br>
&nbsp; 약간의 단계가 늘어?난 것 같지만? 다 편의를 위해서이다. C 언어도 과정이 많이 줄었지만 컴파일을 3번해야되는 번거로움이 있었다. 운영체제가 더 많다면 N번의 컴파일을 해야되는데 만약 파일의 크기가 크다면 컴파일 시간만 해도 엄청날 것이고, 업데이트때마다 이런 반복작업을 하는 것은 번거롭다. 또 개발자들은 반복을 보면 막 묶고 줄이고 싶기 때문에 이런 마음에서 이런 구조에 대한 아이디어가 떠오르지 않았나 싶다. 자바는 이것을 **JDK, JRE, JVM**으로 해냈다.<br>
<br>
&nbsp; JDK, JRE, JVM에 대한 내용도 곧바로 뒤에 나오지만 일단 넘어가고 <ins>얼마나 과정이 축약됐는지만</ins> 살펴보겠다. 일단, 컴파일은 한번만 한다. 이것만 해도 N번의 수고가 덜어졌다. 대신 한가지 전제조건이 붙는데, 각각의 컴퓨터마다 맞는 JRE가 설치되어있어야 한다는 것이다. 컴파일이 N번에서 1번으로 줄었는데 이정도? 해줄 수 있다고 생각한다. 그런 다음 컴파일한 목적파일을 각각의 JRE에서 실행하면 끝이다.
<br>
<br>

- 지금으로 치자면<br>
<br>
&nbsp;윈도우, 맥, 리눅스용 각각의 <ins>JRE</ins>가 필요하다. 만약에 어떤 회사가 어떤 프로그램을 만든다고 하면 각각의 운영체제에 맞는 JRE만 있으면 한번의 컴파일로 돌아간다.<br>
<br>
EX. <br>
<br>
기계어, 어셈블리어 : 윈도우, 맥, 리눅스에 맞게 같은 내용의 코딩을 3번해야한다<br>
C 언어: 한번 코딩을 하고 윈도우, 맥, 리눅스에 맞는 각각의 컴파일러로 총 3번 컴파일한다<br>
JAVA: 한번 코딩하고, 한번 컴파일한다<br>
<br>
총 1개의 파일, 1번의 컴파일<br>
<br>

### 정리
&nbsp; 어쩌다 보니 로우레벨 언어에서 하이레벨 언어까지 사람이 보기 쉬운 접근성과 코딩한 것을 기계가 이해할 수 있게하는 과정에 대한 이식성을 섞어서 말하게 되었는데.. 어쨋든 이식성에 대해 정리해보면
<br>
<br>
![img2](/assets/img/2024-07-26-history/img3.png)
<br>

***JAVA THE GOAT***
